use std::{
    any::{Any, TypeId},
    collections::HashMap,
    sync::Arc,
};

use crate::event::Event;

/// A TaskDef represents any process that is executed by muetl.
pub trait TaskDef {
    fn init(&mut self) -> Result<(), String>;
    fn deinit(self) -> Result<(), String>;
}

pub trait Input<T> {
    const conn_name: &'static str;
    fn handle(&mut self, input: &T) -> Vec<Event>;
}

pub trait Output<T> {
    const conn_name: &'static str;
}

type TaskResult = Result<Vec<Event>, String>;

pub trait Node: TaskDef + Send + Sync {
    fn get_inputs(&self) -> HashMap<String, Vec<TypeId>>;
    fn get_outputs(&self) -> HashMap<String, Vec<TypeId>>;
    fn handle_event(&mut self, ev: &Event) -> TaskResult;

    /// After the underlying event handling has returned a set of Events, validate that each one's
    /// conn_name matches the data type. If any Events do not match the expected conn_name - type
    /// declared by the Node's implementation of Output<T>, then the first error is returned.
    fn validate_output(&self, events: &Vec<Event>) -> Result<(), String> {
        let outputs = self.get_outputs();
        for event in events {
            if let Some(exp_types) = outputs.get(&event.conn_name) {
                if !exp_types.contains(&event.get_data().type_id()) {
                    return Err(
                        format!("output Event for conn named '{}' has invalid type {:?} (expected one of {:?})",
                            event.conn_name,
                            event.get_data().type_id(),
                            exp_types));
                }
            }
        }
        Ok(())
    }
}

// pub trait Source: TaskDef + Send + Sync {
//     // fn get_inputs(&self) -> HashMap<String, Vec<TypeId>>;
//     fn get_outputs(&self) -> HashMap<String, Vec<TypeId>>;
// }

// pub trait Daemon: TaskDef + Send + Sync {
//     // fn get_inputs(&self) -> HashMap<String, Vec<TypeId>>;
//     fn get_outputs(&self) -> HashMap<String, Vec<TypeId>>;
// }

// pub trait Sink: TaskDef + Send + Sync {
//     fn get_inputs(&self) -> HashMap<String, Vec<TypeId>>;
//     // fn get_outputs(&self) -> HashMap<String, Vec<TypeId>>;
// }

struct Test {}
impl TaskDef for Test {
    fn init(&mut self) -> Result<(), String> {
        Ok(())
    }
    fn deinit(self) -> Result<(), String> {
        Ok(())
    }
}

impl Input<String> for Test {
    const conn_name: &'static str = "user id";

    fn handle(&mut self, input: &String) -> Vec<Event> {
        vec![]
    }
}

impl Input<u32> for Test {
    const conn_name: &'static str = "user id";

    fn handle(&mut self, input: &u32) -> Vec<Event> {
        vec![]
    }
}

impl Output<bool> for Test {
    const conn_name: &'static str = "allowed";
}

// Note that there are two types declared for this output!
impl Output<String> for Test {
    const conn_name: &'static str = "user id (output)";
}
impl Output<u32> for Test {
    const conn_name: &'static str = "user id (output)";
}

// EVERYTHING under this line is going to be generated by a macro
//
// TODO: do we need to implement get_inputs and get_outputs, or should the
// macro just handle actual switching/iteration?

impl Node for Test {
    fn get_inputs(&self) -> HashMap<String, Vec<TypeId>> {
        let mut hm = HashMap::new();
        hm.insert(
            "user id".to_string(),
            vec![TypeId::of::<String>(), TypeId::of::<u32>()],
        );
        hm
    }
    fn get_outputs(&self) -> HashMap<String, Vec<TypeId>> {
        let mut hm = HashMap::new();
        hm.insert("allowed".to_string(), vec![TypeId::of::<bool>()]);
        hm.insert(
            "user id (output)".to_string(),
            vec![TypeId::of::<String>(), TypeId::of::<u32>()],
        );
        hm
    }

    // This will be autogenerated via a macro
    fn handle_event(&mut self, ev: &Event) -> TaskResult {
        match ev.conn_name.as_str() {
            "user id" => self.handle_input_1(ev.get_data()),
            _ => Err(format!(
                "received Event for unknown conn named '{}'",
                ev.conn_name
            )),
        }
    }
}

impl Test {
    // TODO: this will be generated by a macro
    /// Handler generated for the first input, which has the conn name 'user id'
    fn handle_input_1(&mut self, data: Arc<dyn Any + Send + Sync>) -> TaskResult {
        if data.type_id() == TypeId::of::<String>() {
            Ok(<Self as Input<String>>::handle(
                self,
                data.downcast_ref::<String>().unwrap(),
            ))
        } else if data.type_id() == TypeId::of::<u32>() {
            Ok(<Self as Input<u32>>::handle(
                self,
                data.downcast_ref::<u32>().unwrap(),
            ))
        } else {
            Err(format!(
                "failed to handle input for conn 'user id': unknown type {:?}",
                data.type_id()
            ))
        }
    }
}
